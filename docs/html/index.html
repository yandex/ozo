<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="DoxyPress 1.3.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OZO: ozo</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxypress.css" rel="stylesheet" type="text/css" />
<link href="customdoxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by DoxyPress -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OZO
   </div>
   <div id="projectbrief">Asychronous header-only Boost.Asio-based PostgreSQL C++17 type-safe library. And yes, it is fast!</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by DoxyPress 1.3.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>API&#160;Reference</span></a></li>
      <li><a href="https://github.com/yandex/ozo"><span>GitHub</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ozo </div>  </div>
  <div class="clear-floats"></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a href="https://travis-ci.org/yandex/ozo"></a> <a href="https://codecov.io/gh/yandex/ozo"></a></p>
<h2>What's this</h2>
<p>OZO is a C++17 library for asyncronous communication with PostgreSQL DBMS. The library leverages the power of template metaprogramming, providing convenient mapping from C++ types to SQL along with rich query building possibilities. OZO supports different concurrency paradigms (callbacks, futures, coroutines), using Boost.Asio under the hood. Low-level communication with PostgreSQL server is done via libpq. All concepts in the library are designed to be easily extendable (even replaceable) by the user to simplify adaptation to specific project requirements.</p>
<h3>API</h3>
<p>Since the project is on early state of development it lacks of documentation. We understand the importance of good docs and are working hard on this problem. Complete documentation is on the way, but now:</p>
<ul>
<li>look at our brand new HOW TO,</li>
<li>try our <a href="docs/html/index.html">generated from sources documentation</a> made with <a href="http://www.copperspice.com/documentation-doxypress.html">Doxypress</a> - it is under construction but readable,</li>
<li>learn more about main use-cases from <a href="tests/request_integration.cpp">unit tests</a>,</li>
<li>See our <a href="https://youtu.be/-1zbaxuUsMA">C++Now'18 talk about OZO</a> with <a href="https://github.com/boostcon/cppnow_presentations_2018/blob/master/05-09-2018_wednesday/design_and_implementation_of_dbms_asynchronous_client_library__roman_siromakha__cppnow_05092018.pdf">presentation</a>.</li>
</ul>
<h2>Dependencies</h2>
<p>These things are needed:</p>
<ul>
<li><b>CMake</b> is used as build system</li>
<li><b>GCC</b> or <b>Clang</b> C++ compiler with C++17 support (tested with GCC 7.0, Clang 5.0 and Apple LLVM version 9.0.0)</li>
<li><b>Boost</b> &gt;= 1.66</li>
<li><b>libpq</b> &gt;= 9.3</li>
</ul>
<p>If you want to run integration tests and/or build inside Docker container:</p><ul>
<li><b>Docker</b> &gt;= 1.13.0</li>
<li><b>Docker Compose</b> &gt;= 1.10.0</li>
</ul>
<h2>Build</h2>
<p>The library is header-only, but if you want to build and run unit-tests you can do it as listed below.</p>
<h3>Build and run tests on custom environment</h3>
<p>First of all you need to satsfy requirements listed above. You can run tests using these commands.</p>
<div class="fragment"><div class="line">mkdir -p build</div><div class="line">cd build</div><div class="line">cmake ..</div><div class="line">make -j$(nproc)</div><div class="line">ctest -V</div></div><!-- fragment --><p>Or use <a href="scripts/build.sh">build.sh</a> which accepts folowing commands:</p>
<div class="fragment"><div class="line">scripts/build.sh help</div></div><!-- fragment --><p>prints help.</p>
<div class="fragment"><div class="line">scripts/build.sh &lt;compiler&gt; &lt;target&gt;</div></div><!-- fragment --><p>build and run tests with specified <b>compiler</b> and <b>target</b>, the <b>compiler</b> parameter can be:</p>
<ul>
<li><b>gcc</b> - for build with gcc,</li>
<li><b>clang</b> - for build with clang.</li>
</ul>
<p>The <b>target</b> parameter depends on <b>compiler</b>. For <b>gcc</b>:</p>
<ul>
<li><b>debug</b> - for debug build and tests</li>
<li><b>release</b> - for release build and tests</li>
<li><b>coverage</b> - for code coverage calculation</li>
</ul>
<p>For <b>clang</b>:</p>
<ul>
<li><b>debug</b> - for debug build and tests</li>
<li><b>release</b> - for release build and tests</li>
<li><b>asan</b> - for <a href="https://clang.llvm.org/docs/AddressSanitizer.html">AddressSanitizer</a> launch</li>
<li><b>ubsan</b> - for <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">UndefinedBehaviorSanitizer</a> launch</li>
<li><b>tsan</b> - for <a href="https://clang.llvm.org/docs/ThreadSanitizer.html">ThreadSanitizer</a> launch</li>
</ul>
<div class="fragment"><div class="line">scripts/build.sh all</div></div><!-- fragment --><p>build all possible configuration.</p>
<h3>Build and run tests on MacOS 10.X</h3>
<p>For MacOS the best way to satisfy minimum requirements is <a href="https://brew.sh/">brew</a></p>
<div class="fragment"><div class="line">brew install cmake boost libpq postresql</div></div><!-- fragment --><h3>Build and run tests within Docker</h3>
<p>To build code and run tests inside docker container:</p>
<div class="fragment"><div class="line">scripts/build.sh docker &lt;compiler&gt; &lt;target&gt;</div></div><!-- fragment --><h3>Test against a local postgres</h3>
<p>You can use <code>scripts/build.sh</code> but add <code>pg</code> first:</p>
<div class="fragment"><div class="line">scripts/build.sh pg &lt;compiler&gt; &lt;target&gt;</div></div><!-- fragment --><p>or if you want build code in docker:</p>
<div class="fragment"><div class="line">scripts/build.sh pg docker &lt;compiler&gt; &lt;target&gt;</div></div><!-- fragment --><p>This will attempt to launch postgres:alpine from your Docker registry. Or you can point ozo tests to a postgres of your choosing by setting these environment variables prior to building:</p>
<div class="fragment"><div class="line">export OZO_BUILD_PG_TESTS=ON</div><div class="line">export OZO_PG_TEST_CONNINFO=&#39;your conninfo (connection string)&#39;</div><div class="line"></div><div class="line">scripts/build.sh gcc debug</div></div><!-- fragment --> </div></div><!-- contents -->
<!-- Generated by DoxyPress 1.3.1 -->
<hr class="footer"/><address class="footer"><small>
Generated on Thu Aug 30 2018 12:50:50 for OZO &nbsp; by &#160;<a href="http://www.copperspice.com/documentation-doxypress.html">
<img class="footer" src="doxypress.png" alt="DoxyPress"/></a> 1.3.1
</small></address>
</body>
</html>
